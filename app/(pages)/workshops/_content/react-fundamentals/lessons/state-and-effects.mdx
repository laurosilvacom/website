---
title: 'State and Effects'
number: 4
duration: '45:00'
section: 'Core Concepts'
---

While props allow components to receive data, they don't allow components to change over time. For that, we need state and effects.

## Component State

State is data that changes over time within a component. Unlike props, which are passed from parent to child, state is managed within the component itself.

In React, we use the `useState` hook to add state to functional components:

```jsx
import React, {useState} from 'react'

function Counter() {
	// Declare a state variable named "count" with initial value of 0
	const [count, setCount] = useState(0)

	return (
		<div>
			<p>You clicked {count} times</p>
			<button onClick={() => setCount(count + 1)}>
				Click me
			</button>
		</div>
	)
}
```

The `useState` hook returns an array with two elements:

1. The current state value
2. A function to update that value

## State Updates Are Asynchronous

It's important to understand that React may batch state updates for performance. If you need to update state based on the previous state, use the functional form:

```jsx
// Instead of this:
setCount(count + 1)

// Do this:
setCount((prevCount) => prevCount + 1)
```

## Multiple State Variables

You can use the `useState` hook multiple times in a single component:

```jsx
function UserForm() {
	const [name, setName] = useState('')
	const [email, setEmail] = useState('')
	const [age, setAge] = useState(25)

	// ...
}
```

## Complex State with Objects

For complex state, you can use objects:

```jsx
function UserForm() {
	const [user, setUser] = useState({
		name: '',
		email: '',
		age: 25
	})

	function handleNameChange(e) {
		// When updating an object, you need to preserve the other fields
		setUser({
			...user,
			name: e.target.value
		})
	}

	// ...
}
```

## Side Effects with useEffect

Side effects are operations that affect something outside the component's scope, such as:

- Data fetching
- Setting up subscriptions
- Manually changing the DOM

React provides the `useEffect` hook to perform side effects:

```jsx
import React, {useState, useEffect} from 'react'

function UserProfile({userId}) {
	const [user, setUser] = useState(null)
	const [loading, setLoading] = useState(true)

	useEffect(() => {
		// This function will run after the component renders
		async function fetchUser() {
			setLoading(true)
			try {
				const response = await fetch(`/api/users/${userId}`)
				const userData = await response.json()
				setUser(userData)
			} catch (error) {
				console.error('Failed to fetch user:', error)
			} finally {
				setLoading(false)
			}
		}

		fetchUser()
	}, [userId]) // Only re-run the effect if userId changes

	if (loading) return <p>Loading...</p>
	if (!user) return <p>User not found</p>

	return (
		<div>
			<h1>{user.name}</h1>
			<p>Email: {user.email}</p>
		</div>
	)
}
```

## The Dependency Array

The second argument to `useEffect` is the dependency array:

- Empty array (`[]`): Effect runs only once after the initial render
- With dependencies (`[userId]`): Effect runs when any dependency changes
- No array: Effect runs after every render

## Cleanup Functions

Some effects need to be cleaned up. For example, if you set up a subscription, you should unsubscribe when the component unmounts:

```jsx
useEffect(() => {
	// Set up subscription
	const subscription = SomeAPI.subscribe()

	// Return a cleanup function
	return () => {
		subscription.unsubscribe()
	}
}, [])
```

The cleanup function runs:

- Before the effect runs again (if dependencies changed)
- When the component unmounts

## Rules of Hooks

When using hooks like `useState` and `useEffect`, you must follow these rules:

1. Only call hooks at the top level of your component
2. Don't call hooks inside loops, conditions, or nested functions
3. Only call hooks from React function components or custom hooks

## Custom Hooks

You can create your own hooks to extract and reuse stateful logic:

```jsx
function useOnlineStatus() {
	const [isOnline, setIsOnline] = useState(navigator.onLine)

	useEffect(() => {
		function handleOnline() {
			setIsOnline(true)
		}

		function handleOffline() {
			setIsOnline(false)
		}

		window.addEventListener('online', handleOnline)
		window.addEventListener('offline', handleOffline)

		return () => {
			window.removeEventListener('online', handleOnline)
			window.removeEventListener('offline', handleOffline)
		}
	}, [])

	return isOnline
}

// Usage
function StatusIndicator() {
	const isOnline = useOnlineStatus()

	return <span>{isOnline ? '✅ Online' : '❌ Offline'}</span>
}
```

Custom hooks are a powerful way to share logic between components.

## Exercises

1. Create a form with multiple fields that updates a state object
2. Build a component that fetches and displays data from an API
3. Create a custom hook that manages a counter with increment and decrement functions
4. Build a timer component that updates every second and cleans up when unmounted

In the next lesson, we'll explore more advanced patterns and learn how to optimize performance in React applications.
